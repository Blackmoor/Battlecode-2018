// import the API.
// See xxx for the javadocs.
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;

import bc.*;

public class Player {
	private static GameController gc;
	private static Team myTeam; //Red or Blue
	private static Team otherTeam;
	private static Planet myPlanet; //(Earth or Mars)
    private static PlanetMap map;	//Initial map 
    private static MapAnalyser mars;
    
    private static VecUnit units; //The list of all known units - updated each turn in the main loop
    private static VecUnit unitsInSpace; //The list of all units on the way to mars
    private static int totalKarbonite; //How much Karbonite is available on the starting map
    private static Random randomness = new Random(1042);    
    private static HashMap<Integer, Long> launchRound = new HashMap<Integer, Long>();
    
    public static void main(String[] args) {
        // Connect to the manager, starting the game
        gc = new GameController();
        myTeam = gc.team();
        if (myTeam == Team.Blue)
        	otherTeam = Team.Red;
        else
        	otherTeam = Team.Blue;

        //Start our research
        gc.queueResearch(UnitType.Rocket); // Allows us to build rockets (100 turns)   
        gc.queueResearch(UnitType.Worker); // Improves Karbonite harvesting (25 turns)
        gc.queueResearch(UnitType.Ranger); // Increase movement rate (25 turns)
        gc.queueResearch(UnitType.Mage); //Increase Damage
        gc.queueResearch(UnitType.Mage); //Increase Damage
        gc.queueResearch(UnitType.Mage); //Increase Damage
        gc.queueResearch(UnitType.Mage); //Blink
        
        //Cache the initial map
        myPlanet = gc.planet();
        map = gc.startingMap(myPlanet);  	
    	scanMap();
    	//debug("Total Karbonite on " + myPlanet + " is " + totalKarbonite);
        
        runPlanet();
    }
    
    private static void debug(String s) {
    	System.out.println(s);
    }
    
	/*
	 * All movement is based on gravity wells generated by points of interest
	 * 
	 * Our units build up a gravity well using the following rules
	 * All units
	 * - Tiles not seen - Strength = turns since last seen, Max = 1
	 * 
	 * Workers
	 * - Karbonite - Strength = Karbonite at location, Max workers = empty locations next to Karbonite
	 * - Asteroid drops - as above but strength reduced according to how long before drop
	 * - Blueprints - Strength = 200, Max = empty locations
	 * - Damaged buildings - Strength = Damage, Max = empty locations
	 * - Rockets - Strength = 1000, Max = capacity
	 * 
	 * Healers
	 * - Damaged allies - Strength = Damage + Cost, Max = 1
	 * - Ranger ally - Strength = 10, Max = 1
	 * - Rocket - Strength = 1000, Max = 1
	 * 
	 * Mages
	 * - Enemy unit - Strength = 5*Cost, Max = 5
	 * - Ranger ally - Strength = 10, Max = 3
	 * - Worker ally - Strength = Cost, Max = 1
	 * - Rocket - Strength = 1000, Max = 3
	 * 
	 * Ranger and Knights
	 * - Enemy unit - Strength = 5*Cost, Max = 5
	 * - Worker ally - Strength = Cost, Max = 1
	 * - Rocket - Strength = 1000, Max = 1
	 *
     * The gravity well maps are stored in arrays that map onto the Planet map
     * High scores are more interesting - units move to an adjacent tile with a higher score if possible
     * 
     * We create these maps each turn that a unit needs to move and only as needed
     */
    
    private static boolean nothingToMine = false; //Set to true once all the karbonite has been mined on Earth
    private static long[][] karboniteMap; //Initialised with starting values and updated as we sense tiles with new values
    private static boolean[][] passable; //Set to true if the location is passable (i.e. not water) - fixed
    
    private static double[][] workerMap = null;
    private static double[][] mageMap = null;
    private static double[][] rangerMap = null;
    private static double[][] healerMap = null;
    private static double[][] knightMap = null;
    
    /*
     * Returns the unit at the given location or null if there isn't one
     */
    private static Unit unitAt(int x, int y) {
    	MapLocation m = new MapLocation(myPlanet, x, y);
    	return unitAt(m);
    }
    
    private static Unit unitAt(MapLocation m) {
    	if (!gc.canSenseLocation(m) || !gc.hasUnitAtLocation(m))
    		return null;
    		
    	return gc.senseUnitAtLocation(m);
    }
    
    private static boolean structureAt(int x, int y) {
    	Unit u = unitAt(x, y);
    	if (u == null)
    		return false;
    	if (u.unitType() == UnitType.Factory)
    		return true;
    	if (u.unitType() == UnitType.Rocket)
    		return true;
    	return false;
    }
    
    /*
     * Ripple out from the given edge (set of points) until a given number of our units have been found scoring each tile as we go - the nearer the higher the score
     * For each location we mark it as open (i.e. on the list to process), closed (processed) or unseen
     */
    public static void ripple(double[][] gravityMap, List<MapLocation> edge, double points, UnitType match, int max) {
    	int UNSEEN = 0, OPEN = 1, CLOSED = 2;
    	int[][] status = new int[(int)map.getWidth()][(int)map.getHeight()];
    	int distance = 0; //How far from the source are we
    	int matchCount = 0; //How many units of the right type have we seen
    	
    	for (MapLocation me: edge) {
    		status[me.getX()][me.getY()] = OPEN;
    	}
    	
    	//debug("ripple: starting points " + edge.size() + " value " + points + " stop when " + max + " " + match);
    	/*
    	 * This is a standard Breadth First Search
    	 * Since we want to know the distance from the source we maintain a current open list (edge)
    	 * and build up the next open list (nextEdge). When edge is processed (empty) we increment the distance and switch to the nextEdge
    	 */
    	while (!edge.isEmpty()) {
    		distance++;
    		List<MapLocation> nextEdge = new LinkedList<MapLocation>();
    		
        	for (MapLocation me: edge) {
        		if (status[me.getX()][me.getY()] != CLOSED) {
        			Unit unit = unitAt(me);
    				if (unit != null && unit.team() == myTeam &&
    						(match == null || match == unit.unitType())) {
						matchCount++;
						if (distance > 1 && matchCount >= max) { //We have reached the cutoff point
							//debug("Ripple match count met: complete at distance " + distance);
							return;
						}
					}
        			
	        		status[me.getX()][me.getY()] = CLOSED;
	        		//debug("Ripple SEEN " + me);

	    			//Score this tile
					gravityMap[me.getX()][me.getY()] += points/(distance*distance);
		       		
	    			//We add adjacent tiles to the next search if they are traversable
		    		for (Direction direction: Direction.values()) {
		    			MapLocation t = me.add(direction);
		    			if (map.onMap(t) && status[t.getX()][t.getY()] == UNSEEN && passable[t.getX()][t.getY()] && !structureAt(t.getX(), t.getY())) {
			    			nextEdge.add(t);
			    			status[t.getX()][t.getY()] = OPEN;
			    			//debug("ripple Added " + t);
		    			}
		    		}
    			}
    		}
    		//debug("Ripple distance " + distance + " edge size = " + nextEdge.size());
    		
    		edge = nextEdge;
    	}
    	
    	//debug("Ripple queue empty: complete at distance " + distance);
    }
    
    public static void ripple(double[][] gravityMap, MapLocation t, double points, UnitType match, int max) {
    	List<MapLocation> edge = new LinkedList<MapLocation>();
    	edge.add(t);

    	ripple(gravityMap, edge, points, match, max);
    }
    
    public static void ripple(double[][] gravityMap, int x, int y, double points, UnitType match, int max) {
    	List<MapLocation> edge = new LinkedList<MapLocation>();
    	edge.add(new MapLocation(myPlanet, x, y));

    	ripple(gravityMap, edge, points, match, max);
    }
    
    /*
     * addRockets
     * 
     * Adds in gravity for all active rockets on earth looking for passengers
     */
    private static void addRockets(double[][] map, double points, UnitType match, int max) {
    	List<MapLocation> targets = new ArrayList<MapLocation>();
    	//Add Rockets that are ready to board and have space
		if (myPlanet == Planet.Earth) {
    		for (Unit b: rockets)
    			targets.add(b.location().mapLocation());
    		ripple(map, targets, points, match, max);
		}
    }
    
    /*
     * Returns true if a unit can attack and damage us
     */
    private static boolean isCombatUnit(Unit u) {
    	switch (u.unitType()) {
    	case Knight:
    	case Ranger:
    	case Mage:
    		return true;
    	default:
    		return false;
    	}
    }
    
    /*
     * addDangerZones
     * 
     * subtracts from all tiles on the map within the attack range of enemy units we can see
     */
    private static void addDangerZones(double[][] map) {
    	//Add enemies danger zones
    	for (Unit u:enemies) {
    		if (isCombatUnit(u)) { //This unit can attack and damage us
	    		MapLocation enemyLoc = u.location().mapLocation();
	    		VecMapLocation tiles =  gc.allLocationsWithin(enemyLoc, u.attackRange());
	    		for (int i=0; i<tiles.size(); i++) {
	    			MapLocation m = tiles.get(i);
	    			int x = m.getX(), y = m.getY();
	    			map[x][y] -= 50;
	    		}
    		}
    	}	
    }
    
    /*
     * Rangers are combat units
     * They move towards enemy units, our workers (to protect them) and rockets.
     * 
	 * - Enemy unit - Strength = 5*Cost, Max = 5
	 * - Worker ally - Strength = Cost, Max = 1
	 * - Rocket - Strength = 1000, Max = 1
     */
    private static void updateRangerMap() {
    	if (rangerMap != null) //We have already done it
    		return;
    	
    	rangerMap = new double[(int) map.getWidth()][(int) map.getHeight()];
    	List<MapLocation> targets = new ArrayList<MapLocation>();
    	int rangerCount = myLandUnits[UnitType.Ranger.ordinal()];
    	
    	//Add enemies
    	for (Unit u:enemies) {
    		//We want to be at our attack distance from each enemy
    		MapLocation enemyLoc = u.location().mapLocation();
    		VecMapLocation tiles =  gc.allLocationsWithin(enemyLoc, 50);
    		for (int i=0; i<tiles.size(); i++) {
    			MapLocation m = tiles.get(i);
    			//We only want the tiles that are a reasonable distance from the enemy
    			if (m.distanceSquaredTo(enemyLoc) > 30)
    				targets.add(m);
    			else {
    				int x = m.getX(), y = m.getY();
    				rangerMap[x][y] -= 50;
    			}
    		}
    	}
    	//debug("updateRangerMap: added " + enemies.size() + " enemies and " + targets.size() + " tiles");
    	ripple(rangerMap, targets, 100, UnitType.Ranger, rangerCount);
    	
    	addRockets(rangerMap, 1000, UnitType.Ranger, 1);
    }
    
    private static void updateMageMap() {
    	if (mageMap != null) //We have already done it
    		return;
    	
    	mageMap = new double[(int) map.getWidth()][(int) map.getHeight()];
    	List<MapLocation> targets = new ArrayList<MapLocation>();
    	int mageCount = myLandUnits[UnitType.Mage.ordinal()];
    	
    	//Add enemies
    	for (Unit u:enemies) {
    		//We want to be at our attack distance from each enemy
    		MapLocation enemyLoc = u.location().mapLocation();
    		VecMapLocation tiles =  gc.allLocationsWithin(enemyLoc, 30);
    		for (int i=0; i<tiles.size(); i++) {
    			MapLocation m = tiles.get(i);
    			//We only want the tiles that are a reasonable distance from the enemy
    			if (m.distanceSquaredTo(enemyLoc) > 20)
    				targets.add(m);
    			else {
    				int x = m.getX(), y = m.getY();
    				mageMap[x][y] -= 50;
    			}
    		}
    	}
    	
    	ripple(mageMap, targets, 100, UnitType.Mage, mageCount);
    	
    	addRockets(mageMap, 1000, UnitType.Mage, 1);
    }
    
    /*
     * Healers need to move towards damaged allies (not structures)
     * Like all other units they will board waiting rockets
     */
    private static void updateHealerMap() {
    	if (healerMap != null) //We have already done it
    		return;
    	
    	healerMap = new double[(int) map.getWidth()][(int) map.getHeight()];
    	List<MapLocation> targets = new ArrayList<MapLocation>();
    	int healerCount = myLandUnits[UnitType.Healer.ordinal()];
    	
    	//Add damaged units
    	for (Unit u:unitsToHeal)
    		targets.add(u.location().mapLocation());
    	ripple(healerMap, targets, 100, UnitType.Healer, healerCount);
    	
    	addDangerZones(healerMap);
		addRockets(healerMap, 1000, UnitType.Healer, 1);
    }
    
    private static void updateKnightMap() {
    	if (knightMap != null) //We have already done it
    		return;
    	
    	knightMap = new double[(int) map.getWidth()][(int) map.getHeight()];
    	List<MapLocation> targets = new ArrayList<MapLocation>();
    	int knightCount = myLandUnits[UnitType.Knight.ordinal()];
    	
    	//Add enemies
    	for (Unit u:enemies)
    		targets.add(u.location().mapLocation());
    	
    	ripple(knightMap, targets, 100, UnitType.Knight, knightCount);
    	
    	addRockets(knightMap, 1000, UnitType.Knight, 1);
    }
    
    /*
     * Workers are the busiest!
     * They respond to Karbonite, blueprints and damaged structures
     * Like all units they also board rockets when built
     */
    private static void updateWorkerMap() {
    	if (workerMap != null) //We have already done it
    		return;
    	
		workerMap = new double[(int) map.getWidth()][(int) map.getHeight()];
		List<MapLocation> targets = new ArrayList<MapLocation>();
		int workerCount = myLandUnits[UnitType.Worker.ordinal()];
		
		//Add Karbonite deposits
		if (!nothingToMine) {
			for (int x=0; x<map.getWidth(); x++) {
				for (int y=0; y<map.getHeight(); y++) {
					if (karboniteMap[x][y] > 0) {
						targets.add(new MapLocation(myPlanet, x, y));
					}
				}
			}
			ripple(workerMap, targets, 10, UnitType.Worker, workerCount);
			if (myPlanet == Planet.Earth && targets.size() == 0)
				nothingToMine = true;
		}
		
		//Add blueprints and damaged buildings
		targets.clear();
		for (Unit b: unitsToBuild)
			targets.add(b.location().mapLocation());
		for (Unit b: unitsToRepair)
			targets.add(b.location().mapLocation());
		ripple(workerMap, targets, 200, UnitType.Worker, Math.min(workerCount, 8));
		
		addDangerZones(workerMap);
		addRockets(workerMap, 1000, UnitType.Worker, Math.min(workerCount, 8));
    }
    
    private static void clearGavityMaps() {
    	workerMap = null;
    	rangerMap = null;
    	knightMap = null;
    	mageMap = null;
    	healerMap = null;
    }
    
    private static double[][] getGravityMap(UnitType type) {
    	switch (type) {
    	case Worker:
    		if (workerMap == null)
    			updateWorkerMap();
    		return workerMap;
    	case Ranger:
    		if (rangerMap == null)
    			updateRangerMap();
    		return rangerMap;
    	case Mage:
    		if (mageMap == null)
    			updateMageMap();
    		return mageMap;
    	case Healer:
    		if (healerMap == null)
    			updateHealerMap();
    		return healerMap;
    	case Knight:
    		if (knightMap == null)
    			updateKnightMap();
    		return knightMap;
    	default:
    		return null;
    	}
    }
    
    /*
     * Scan the map data and record the locations of karbonite, the number of passable neighbours each tile has
     * and return the total karbonite on the map
     * 
     * This is called once on the first turn
     * 
     * TODO - analyse Mars and count how many separate areas there are and how much karbonite will appear in each area
     * We need to send a rocket to each area
     */
    private static void scanMap() {
    	totalKarbonite = 0;
    	karboniteMap = new long[(int) map.getWidth()][(int) map.getHeight()];
    	passable = new boolean[(int) map.getWidth()][(int) map.getHeight()];
    	
    	for (int x = 0; x<map.getWidth(); x++) {
    		for (int y=0; y<map.getHeight(); y++) {
    			MapLocation here = new MapLocation(myPlanet, x, y);
    			karboniteMap[x][y] = map.initialKarboniteAt(here);
    			totalKarbonite += karboniteMap[x][y];    			
    			passable[x][y] = (map.onMap(here) && map.isPassableTerrainAt(here) > 0);
    		}
    	}
    	
    	if (myPlanet == Planet.Earth) {
    		if (totalKarbonite == 0)
    			nothingToMine = true;
    		mars = new MapAnalyser(gc);
    	}
    }   
    
    /*
     * Given a gravity map we find the highest scoring tile adjacent to us
     * This could be one of our static buildings or an empty tile
     */
    private static Direction bestMove(Unit t, double[][] gravityMap) {
    	Direction best = null;
    	
    	if (!t.location().isOnMap())
    		return null;
    	
    	MapLocation myLoc = t.location().mapLocation();
    	double bestScore = gravityMap[myLoc.getX()][myLoc.getY()];
    	//debug("bestMove from " + myLoc + " current score " + bestScore);
    	List<MapLocation> options = allMoveNeighbours(myLoc);
    	for (MapLocation test: options) {
    		Direction d = myLoc.directionTo(test);
    		if (gravityMap[test.getX()][test.getY()] > bestScore ||
    				(gravityMap[test.getX()][test.getY()] == bestScore && randomness.nextBoolean())) {
    			bestScore = gravityMap[test.getX()][test.getY()];
    			best = d;
    		}
    	}
    	//debug ("is " + best + " with a score of " + bestScore);
		return best;
    }
    
    /*
     * updateKarbonite
     * 
     * Use current sense data to update any changes to karbonite
     * If Earth now has no Karbonite we can skip the update as no more will appear
     */
    private static void updateKarbonite() {
    	
    	if (!nothingToMine) {
	    	for (int x = 0; x<map.getWidth(); x++) {
	    		for (int y=0; y<map.getHeight(); y++) {
	    			MapLocation test = new MapLocation(myPlanet, x, y);
	    			if (gc.canSenseLocation(test)) {
	    				karboniteMap[x][y] = gc.karboniteAt(test);
	    			}
	    		}
	    	}
    	}	    	
    	
    	if (myPlanet == Planet.Mars) {
    		if (gc.asteroidPattern().hasAsteroid(gc.round())) {
    			MapLocation strike = gc.asteroidPattern().asteroid(gc.round()).getLocation();
    			long karbonite = gc.asteroidPattern().asteroid(gc.round()).getKarbonite();
    			int x = strike.getX(), y = strike.getY();
    			karboniteMap[x][y] += karbonite;
    		}
    	}
    }
    
    private static int[] myLandUnits; //Counts of how many units we have indexed by unit type (ordinal)
    private static int[] mySpaceUnits; //Counts of how many units we have indexed by unit type (ordinal)
    private static List<Unit> unitsToBuild; //List of current blueprints that need building
    private static List<Unit> unitsToHeal; //List of units that need healing
    private static List<Unit> unitsToRepair; //List of buildings that need repair
    private static List<Unit> rockets; //List of rockets (to Load into if on Earth, or unload from on Mars)
    private static List<Unit> enemies; //List of all enemy units in sight
    
    /*
     * Loop through the units we are aware of and update our cache
     * Called once each turn
     */
    private static void updateUnits() {
        units = gc.units(); //All the units we can see on the map (but not the ones in garisons)
        unitsInSpace = gc.unitsInSpace(); //All the units in space
    	myLandUnits = new int[UnitType.values().length];
    	mySpaceUnits = new int[UnitType.values().length];
    	unitsToBuild = new ArrayList<Unit>();
    	unitsToHeal = new ArrayList<Unit>();
    	unitsToRepair = new ArrayList<Unit>();
    	rockets = new ArrayList<Unit>();
    	enemies = new ArrayList<Unit>();
    	
    	for (int i = 0; i < units.size(); i++) {
            Unit unit = units.get(i);
            
            if (unit.location().isOnMap()) {
            	if (unit.team() == myTeam) {
            		myLandUnits[unit.unitType().ordinal()]++;
            		if (unit.unitType().equals(UnitType.Factory) || unit.unitType().equals(UnitType.Rocket)) {
            			if (unit.structureIsBuilt() == 0)
            				unitsToBuild.add(unit);
            			else if (unit.health() < unit.maxHealth())
            				unitsToRepair.add(unit);
            			if (unit.unitType().equals(UnitType.Rocket) && unit.rocketIsUsed() == 0)
            				rockets.add(unit);
            			
            			VecUnitID garrison = unit.structureGarrison();
            			for (int j=0; j<garrison.size(); j++) {
            				int id = garrison.get(j);
            				myLandUnits[gc.unit(id).unitType().ordinal()]++;
            			}
            		} else {
            			if (unit.health() < unit.maxHealth())
            				unitsToHeal.add(unit);
            		}
            	} else { //enemies
            		enemies.add(unit);
            	}
            }
    	}
    	
    	for (int i=0; i<unitsInSpace.size(); i++) {
    		Unit unit = unitsInSpace.get(i);
    		mySpaceUnits[unit.unitType().ordinal()]++;
    	}
    	
    	/*
    	String unitInfo = "";
    	for (UnitType t: UnitType.values())
    		if (myLandUnits[t.ordinal()] > 0)
    			unitInfo += t + " = " + myLandUnits[t.ordinal()] + " ";
    	if (unitInfo.length() > 0)
    		debug("On " + myPlanet + ": " + unitInfo);
    	
    	unitInfo = "";
    	for (UnitType t: UnitType.values())
    		if (mySpaceUnits[t.ordinal()] > 0)
    			unitInfo += t + " = " + mySpaceUnits[t.ordinal()] + " ";
    	if (unitInfo.length() > 0)
    		debug("In space: " + unitInfo);
    	*/
    	
    }
   
    /*
     * Returns an array containing all the open neighbours of a map location
     * Open means on the map and not water and doesn't contain a unit
     */
    private static List<MapLocation> allOpenNeighbours(MapLocation l) {
    	List<MapLocation> result = new ArrayList<MapLocation>();
    	VecMapLocation all = gc.allLocationsWithin(l, 2);
    	
    	for (int i=0; i<all.size(); i++) {
    		MapLocation test = all.get(i);
    		if (passable[test.getX()][test.getY()] && !gc.hasUnitAtLocation(test))
				result.add(test);
		}
    	
    	return result;
    }
    
    /*
     * Factories and Rockets are structures
     */
    private static boolean isOurStructure(Unit u) {
    	if (u == null || u.team() != myTeam)
    		return false;
    	switch (u.unitType()) {
    	case Factory:
    	case Rocket:
    		return true;
    	default:
    		return false;
    	}
    }
    
    /*
     * Returns an array containing all the neighbours of a map location we can move to
     * Open means on the map and not water and doesn't contain a mobile unit (but can contain structures)
     */
    private static List<MapLocation> allMoveNeighbours(MapLocation l) {
    	List<MapLocation> result = new ArrayList<MapLocation>();
    	VecMapLocation all = gc.allLocationsWithin(l, 2);
    	
    	for (int i=0; i<all.size(); i++) {
    		MapLocation test = all.get(i);
    		int x = test.getX(), y = test.getY();
    		Unit u = unitAt(test);
			if (passable[x][y] &&
					(u == null || isOurStructure(u)))
				result.add(test);
		}
    	
    	return result;
    }
    
    private static void manageWorker(Unit unit) {
    	if (!unit.unitType().equals(UnitType.Worker))
    		return;
    	
    	int id = unit.id();
    	
    	if (!unit.location().isInSpace() && unit.location().isOnMap()) {
    		MapLocation loc = unit.location().mapLocation();
        	List<MapLocation> options = allOpenNeighbours(loc);
        	Direction dir = null;
        	if (!options.isEmpty())
        		dir = loc.directionTo(options.get(0));

        	//Check to see if we can replicate
        	if (dir != null && myLandUnits[UnitType.Worker.ordinal()] + mySpaceUnits[UnitType.Worker.ordinal()] < 16) {
            	if (gc.canReplicate(id, dir)) {
            		gc.replicate(id, dir);
            		myLandUnits[UnitType.Worker.ordinal()]++;
            		//debug("worker replicating");
            	}
        	}	                    
            
        	//Do we want to move to a better location
            if (gc.isMoveReady(id))
            	moveUnit(unit);
            
            //Can we help build something
            if (unit.workerHasActed() == 0) {            
	            VecUnit nearby = gc.senseNearbyUnits(loc, 2); //Adjacent units
						
				for (int k = 0; k < nearby.size(); k++) {
					Unit other = nearby.get(k);
					if (gc.canBuild(id, other.id())) {
						gc.build(id, other.id());
						//debug("worker building");
						break;
					}
				}
            }
            
			//Can we Harvest
			if (unit.workerHasActed() == 0) {
				for (Direction d: Direction.values()) {
					if (gc.canHarvest(id, d)) {
						gc.harvest(id, d);
						//debug("worker harvesting");
						break;
					}
				}
			}
			
			/*
			 * Now check to see if we want to build a factory or a rocket
			 * On Earth we only build one factory and enough rockets for all our mobile units
			 * 
			 * On Mars we build no rockets an multiple factories
			 */			
			if (dir != null && gc.planet() == Planet.Earth && unit.workerHasActed() == 0) {
				if  (myLandUnits[UnitType.Factory.ordinal()] == 0 &&
						gc.karbonite() >= bc.bcUnitTypeBlueprintCost(UnitType.Factory) &&
						gc.canBlueprint(id, UnitType.Factory, dir)) {
					gc.blueprint(id, UnitType.Factory, dir);
					myLandUnits[UnitType.Factory.ordinal()]++;
				} else if (myLandUnits[UnitType.Worker.ordinal()] + 
						myLandUnits[UnitType.Ranger.ordinal()] +
						myLandUnits[UnitType.Mage.ordinal()] +
						myLandUnits[UnitType.Knight.ordinal()] +
						myLandUnits[UnitType.Healer.ordinal()] > myLandUnits[UnitType.Rocket.ordinal()] * 8 &&
						gc.karbonite() >= bc.bcUnitTypeBlueprintCost(UnitType.Rocket)
						&& gc.canBlueprint(id, UnitType.Rocket, dir)) {
					gc.blueprint(id, UnitType.Rocket, dir);
					myLandUnits[UnitType.Rocket.ordinal()]++;
				}
			}
        }
    }
    
    private static int marsZone = 0;
    
    private static MapLocation launchDestination() {
    	//Pick a random tile in the given zone
    	MapZone zone = mars.zones.get(marsZone);
    	int size = zone.tiles.size();
    	
    	return zone.tiles.get(randomness.nextInt(size));  	
    }
    
    private static long getLaunchRound(Unit u) {
    	if (u.structureIsBuilt() == 0)
    		return 749; //TODO - find constant and use it
    	
    	int id = u.id();
    	if (launchRound.containsKey(id))
    		return launchRound.get(id);
    	
    	long round = 749;
    	if (gc.round() + 50 < round)
    		round = gc.round() + 50;
    	
    	launchRound.put(id, round);
    	//debug("Rocket id " + id + " will launch on round " + round);
    	return round;
    }
    
    /*
     * Rockets leave Earth when full or we reach the launch time
     */
    private static void manageRocket(Unit unit) {
    	if (!unit.unitType().equals(UnitType.Rocket))
    		return;
    	
    	int id = unit.id();
    	if (myPlanet == Planet.Earth) {
    		//Check to see if we are have a launch time or are full
    		MapLocation dest = launchDestination();
    		if (gc.canLaunchRocket(id, dest)) {
    			boolean launchNow = (unit.structureGarrison().size() >= unit.structureMaxCapacity());
    			if (!launchNow && gc.round() >= getLaunchRound(unit))
    				launchNow = true;
    			if (launchNow) {
    				//debug("Launching rocket " + id + " to " + dest + " ETA " + gc.currentDurationOfFlight() + " rnds");
    				gc.launchRocket(id, dest);
    				launchRound.remove(id);
    				
    				//Send next rocket to next zone
    		    	marsZone++;
    		    	if (marsZone >= mars.zones.size())
    		    		marsZone = 0;  
    			}
    		}
    	} else {
    		// On Mars we wait for everyone to unload then self destruct
    		if (unit.rocketIsUsed() > 0) {
    			if (unit.structureGarrison().size() == 0)
    				unit.delete(); //TODO - this doesn't work
    			else {
    				//We don't know the unit type so use the worker movement map
    				Direction dir = bestMove(unit, getGravityMap(UnitType.Worker));
    		    	if (dir != null && gc.canUnload(id, dir))
    		    		gc.unload(id, dir);
    			}
    		}
    	}
    }
    
    /*
     * Factories produce combat units and allow other units (workers) to move through them
     */
    private static void manageFactory(Unit unit) {
    	if (!unit.unitType().equals(UnitType.Factory))
    		return;
    	
    	int fid = unit.id();
    	
    	//Unload units if possible
    	if (unit.structureGarrison().size() > 0) {
	    	Direction dir = bestMove(unit, getGravityMap(UnitType.Worker));
	    	if (dir != null && gc.canUnload(fid, dir)) {
	    		gc.unload(fid, dir);
	    		//debug("unloading from factory");
	    	}
    	}
    	
    	//Produce units
    	//We want squads consisting of 1 ranger, 3 mages and a healer
    	UnitType produce = UnitType.Ranger;
    	if (myLandUnits[UnitType.Mage.ordinal()] < 3 * myLandUnits[UnitType.Ranger.ordinal()])
    		produce = UnitType.Mage;
    	else if (myLandUnits[UnitType.Healer.ordinal()] < myLandUnits[UnitType.Ranger.ordinal()])
    		produce = UnitType.Healer;
    	
    	if (gc.canProduceRobot(fid, produce)) {
			gc.produceRobot(fid, produce);
		}
    }
    
    private static void manageMage(Unit unit) {
    	manageRanger(unit);
    }
    
    /*
     * manageRanger
     * 
     * As a combat unit we attack enemies and scout
     */
    private static void manageRanger(Unit unit) {
    	int id = unit.id();
    	boolean canAttack = (unit.attackHeat() < 10);
    	
    	//Rangers need to be mobile - we need to be able to shoot then move or to move then shoot
    	
    	if (canAttack) {
    		int targetId = bestTarget(unit);
    		if (targetId > -1) {
    			gc.attack(id, targetId);
    			//debug("Unit " + id + " " + unit.unitType() + " firing on " + targetId);
        		canAttack = false;
    		}
    	}  	
    	
    	//Do we want to move to a better location
        if (gc.isMoveReady(id))
        	moveUnit(unit);
        	
        if (canAttack) {
    		int targetId = bestTarget(unit);
    		if (targetId > -1) {
    			gc.attack(id, targetId);
    			//debug("Unit " + id + " " + unit.unitType() + " firing on " + targetId);
    		}
    	}  
    }
    
    private static void manageKnight(Unit unit) {
    	manageRanger(unit);
    }
    
    /*
     * manageHealer
     * 
     * We don't fight so we heal anyone in range
     */
    private static void manageHealer(Unit unit) {
    	int id = unit.id();
    	
    	if (gc.isMoveReady(id))
        	moveUnit(unit);
    	
    	if (unit.location().isOnMap()) {
	    	VecUnit inSight = gc.senseNearbyUnitsByTeam(unit.location().mapLocation(), unit.attackRange(), myTeam);
	    	for (int i=0; i<inSight.size(); i++) {
	    		Unit ally = inSight.get(i);
	    		if (ally.health() < ally.maxHealth() && gc.canHeal(id, ally.id())) {
	    			gc.heal(id, ally.id());
	    			break;
	    		}
	    	}
    	}
    }
    
    /*
     * Look for a target in range and pick the one with the most damage to fire on
     */
    private static int bestTarget(Unit unit) {
    	if (!unit.location().isOnMap())
    		return -1;
    	
    	VecUnit inSight = gc.senseNearbyUnitsByTeam(unit.location().mapLocation(), unit.attackRange(), otherTeam);
    	//Pick the enemy with the most damage that is in range
    	int best = -1, id = unit.id();
    	long mostDamage = -1;
    	
    	for (int i=0; i<inSight.size(); i++) {
    		Unit enemy = inSight.get(i);
    		if (gc.canAttack(id, enemy.id()) && enemy.maxHealth() - enemy.health() > mostDamage) {
    			best = enemy.id();
    			mostDamage = enemy.maxHealth() - enemy.health();
    		}
    	}
    	
    	return best;
    }
    
    
    private static void moveUnit(Unit unit) {
    	if (!unit.location().isOnMap())
    		return;
    	
    	Direction d = bestMove(unit, getGravityMap(unit.unitType()));
    	
    	if (d != null) {
        	MapLocation loc = unit.location().mapLocation();
        	int id = unit.id();
    		MapLocation dest = loc.add(d);
    		
    		if (gc.canMove(id, d)) {
    			gc.moveRobot(id, d);
    		} else if (unit.location().isInGarrison()) {
    			Unit structure = unitAt(loc);
    			if (structure != null && gc.canUnload(structure.id(), d)) {
    				gc.unload(structure.id(), d);
    			}
    		} else { //Check to see if there is a structure of ours there
    			Unit structure = unitAt(dest);
    			if (structure != null) {
	    			if (gc.canLoad(structure.id(), id)) {
	    				gc.load(structure.id(), id);
	    			}
    			}
    		}
    	}	
    }
    
    private static void runPlanet() {
    	
        while (true) {
        	try {
	            updateUnits(); //All units we can see - allies and enemies
	            updateKarbonite(); //Current known karbonite values
	            clearGavityMaps(); //Clear the old maps and recreate as required
	            
	            for (int i = 0; i < units.size(); i++) {
	                Unit unit = units.get(i);
	                
	                if (unit.team() == myTeam) {
		                // Most methods on gc take unit IDs, instead of the unit objects themselves.
		  
	                	switch(unit.unitType()) {
	                	case Worker:
	                		manageWorker(unit);
	                		break;
	                	case Knight:
	                		manageKnight(unit);
	                		break;
	                	case Ranger:
	                		manageRanger(unit);
	                		break;
	                	case Mage:
	                		manageMage(unit);
	                		break;
	                	case Rocket:
	                		manageRocket(unit);
	                		break;
	                	case Factory:
	                		manageFactory(unit);
	                		break;
	                	case Healer:
	                		manageHealer(unit);
	                	default: //Unknown unit
	                		break;
	                	}
		                
	                }
	            }
	            // Submit the actions we've done, and wait for our next turn.
	            gc.nextTurn();
        	} catch (Exception e) {
        		//Ignore
        		debug("Caught exception " + e);
        		e.printStackTrace();
        	}
        }
    }
}